<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zichengma.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":250,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="ECE391 MP3 Notes about all the documents and materials related to ECE391 MP3.   FA22 Group 11 — ZinixOS   Mmebers: Zicheng Ma, Ziyuan Chen, Zhirong Chen, Shihua Zeng   Language: 中文+English  FA22 ECE39">
<meta property="og:type" content="article">
<meta property="og:title" content="ECE391-MP3-Tutorial">
<meta property="og:url" content="https://zichengma.github.io/ECE391-MP3-Tutorial/index.html">
<meta property="og:site_name" content="Zicheng Ma&#39;s Blog">
<meta property="og:description" content="ECE391 MP3 Notes about all the documents and materials related to ECE391 MP3.   FA22 Group 11 — ZinixOS   Mmebers: Zicheng Ma, Ziyuan Chen, Zhirong Chen, Shihua Zeng   Language: 中文+English  FA22 ECE39">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled1.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled2.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled3.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled4.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled5.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled6.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled7.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled8.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled9.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled10.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled11.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled12.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled.jpeg">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled13.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled14.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled15.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled16.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled17.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled18.png">
<meta property="og:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled19.png">
<meta property="article:published_time" content="2023-01-13T23:37:54.000Z">
<meta property="article:modified_time" content="2023-01-14T02:40:23.257Z">
<meta property="article:author" content="Zicheng Ma">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zichengma.github.io/ECE391-MP3-Tutorial/Untitled.png">

<link rel="canonical" href="https://zichengma.github.io/ECE391-MP3-Tutorial/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ECE391-MP3-Tutorial | Zicheng Ma's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zicheng Ma's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/About-me" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-test">

    <a href="/test-page" rel="section"><i class="fa fa-mask fa-fw"></i>Test</a>

  </li>
        <li class="menu-item menu-item-course_notes">

    <a href="/CourseNotes" rel="section"><i class="fa fa-book-open fa-fw"></i>Course Notes</a>

  </li>
        <li class="menu-item menu-item-projects">

    <a href="/Projects" rel="section"><i class="fa fa-code fa-fw"></i>Projects</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zichengma.github.io/ECE391-MP3-Tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zicheng Ma">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zicheng Ma's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ECE391-MP3-Tutorial
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-01-13 17:37:54 / Modified: 20:40:23" itemprop="dateCreated datePublished" datetime="2023-01-13T17:37:54-06:00">2023-01-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="ECE391-MP3"><a href="#ECE391-MP3" class="headerlink" title="ECE391 MP3"></a>ECE391 MP3</h1><blockquote>
<p><em><strong>Notes about all the documents and materials related to ECE391 MP3.</strong></em></p>
</blockquote>
<blockquote>
<p><em><strong>FA22 Group 11 — ZinixOS</strong></em></p>
</blockquote>
<blockquote>
<p>Mmebers: Zicheng Ma, Ziyuan Chen, Zhirong Chen, Shihua Zeng</p>
</blockquote>
<blockquote>
<p>Language: 中文+English</p>
</blockquote>
<p>FA22 ECE391本人最终评分A+，侧面表明这篇文档在一定程度上还是可以信赖的，而且有我的队友对文档进行查改和补充<del><em>但如果写出bug，本人概不负责</em></del> 🤣 😋</p>
<p>REFERENCE:  OSdev相关资料，TA Jerry Wang’s slides</p>
<h1 id="Checkpoint-1"><a href="#Checkpoint-1" class="headerlink" title="Checkpoint 1"></a>Checkpoint 1</h1><h2 id="OS-Booting-GDT-amp-IDT-Setup"><a href="#OS-Booting-GDT-amp-IDT-Setup" class="headerlink" title="OS Booting: GDT &amp; IDT Setup"></a>OS Booting: GDT &amp; IDT Setup</h2><h3 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h3><p>reference: <a target="_blank" rel="noopener" href="https://wiki.osdev.org/Global_Descriptor_Table">https://wiki.osdev.org/Global_Descriptor_Table</a></p>
<p>在<code>x86_desc.S</code>中创建<code>gdt_desc</code>标记（参考<code>ldt_desc</code>）</p>
<ul>
<li>48bytes，包括<code>.word</code>长度的limit和<code>.long</code>长度的base</li>
</ul>
<p>在<code>boot.S</code>中用<code>lgdt gdt_desc</code>载入</p>
<h3 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h3><p>reference: <a target="_blank" rel="noopener" href="https://wiki.osdev.org/Interrupt_Descriptor_Table">https://wiki.osdev.org/Interrupt_Descriptor_Table</a></p>
<p>在<code>interrupt.c</code>中定义handlers</p>
<ul>
<li>对于Exception，打印错误信息+无限循环（“蓝屏”）<strong>（后续ckpt会处理如何跳出无限循环）</strong></li>
<li>对于Interrupt，在函数体中调用linkage<strong><strong><strong><strong><strong><strong>（无参数）</strong></strong></strong></strong></strong></strong>，在asm中定义linkage函数（Push all, call handler, pop all, <strong><strong><strong><strong>iret</strong></strong></strong></strong>）<ul>
<li>需要调用linkage的原因是，C function在结束后默认使用ret，而interrupt结束后需要从kernel跳回到user space，使用的是iret。利用asm linkage来完成这一步跳转，用C function来完成每个interrupt handler的具体工作。</li>
</ul>
</li>
<li>利用定义好的SET_IDT_ENTRY来设置IDT中指向的linkage&#x2F;function</li>
</ul>
<h2 id="Device-and-Interrupt"><a href="#Device-and-Interrupt" class="headerlink" title="Device and Interrupt"></a>Device and Interrupt</h2><hr>
<h3 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h3><p>reference:<a target="_blank" rel="noopener" href="https://wiki.osdev.org/PIC">https://wiki.osdev.org/PIC</a></p>
<p>PIC所使用port位置</p>
<p><img src="/ECE391-MP3-Tutorial/Untitled.png" alt="Untitled"></p>
<p>在IDT中，PIC_MASTER使用<strong>0x20-0x27</strong> vector呼叫handler，PIC_SLAVE使用<strong>0x28-0x2F</strong>呼叫handler</p>
<p>PIC_SLAVE链接到PIC_MASTER的<strong>2号vector</strong></p>
<hr>
<p><em><strong>Initialization:</strong></em></p>
<ol>
<li>mask掉所有interrupt（向data port传入0xff）</li>
<li>先给予0x11 command，然后PIC会等待接下来3个传入参数进行初始化（ICW1)</li>
<li>接下来确定在IDT中的位置(ICW2)</li>
<li>决定Master和Slave的cascade状况(ICW3)</li>
<li>最后向Data port传入这是x86模式，以适配x86模式进行工作</li>
</ol>
<p>主要对着Lecture10 PPT写即可</p>
<hr>
<p><em><strong>enable_irq &#x2F; disable_irq:</strong></em></p>
<p>PIC内部存在一个register Interrupt Mask Register，共8bit，当对应bit位被set为1时，PIC会忽略对应位置irq。注意: mask数字高的irq不会影响数字低的irq（priority更高的irq）</p>
<p>先判断irq是否超过7，若超过7，向PIC_SLAVE的data port传入数据，否则向PIC_MASTERdata port传入数据</p>
<img src="/ECE391-MP3-Tutorial/Untitled1.png" alt="Untitled" style="zoom:50%;">

<img src="/ECE391-MP3-Tutorial/Untitled2.png" alt="Untitled" style="zoom:50%;">

<hr>
<p><em><strong>send_EOI:</strong></em></p>
<p>同样需要检查irq number。无论如何都要给MASTER command port send EOI，如果是SLAVE的handler结束，那就给SLAVE也补上</p>
<p>注意: 我们的代码中EOI在send之前需要和irq做一个OR操作，以告知PIC是哪一个irq结束</p>
<p><img src="/ECE391-MP3-Tutorial/Untitled3.png" alt="Untitled"></p>
<p>补充：以上函数均需要做<strong>sanity check</strong>，不允许传入的irq number是一个0-15以外的数值</p>
<hr>
<h3 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h3><p>RTC可以以多个频率运行，基础频率32.768kHz，可以用divider register改变，但是不要变，要不然不准。对于interrupt，默认产生interrupt的频率是1024Hz，可以自行修改，the RTC can theoretically generate **15 interrupt rates between 2 Hz and 32768 Hz (**2^1-2^15)</p>
<p>RTC handler期间，禁用NMI，否则导致RTC变成不可用状态</p>
<p>RTC使用<strong>port 0x70和0x71</strong>，0x70用来指示用哪个register，0x71包含数据。在选择register时可以顺带mask掉NMI</p>
<p><img src="/ECE391-MP3-Tutorial/Untitled4.png" alt="Untitled"></p>
<hr>
<p><em><strong>Initialization:</strong></em></p>
<ol>
<li>打开IRQ8  这里reset原因是每次读写完之后，port 0x70的内容都会被清零，需要重新指定register，然后在这之后要<code>enable_irq(8)</code></li>
</ol>
<p><img src="/ECE391-MP3-Tutorial/Untitled5.png" alt="Untitled"></p>
<ol>
<li><p>选择interrupt产生的frequency</p>
<p> 寄存器A的低4位，是divider value，默认位0110即6，所以默认frequency &#x3D; 2^15&gt;&gt;(6-1) &#x3D; 1024</p>
<p> 设置好寄存器A的低4位(称为rate)后，最终<strong>frequency &#x3D; 2^15 &gt;&gt;(rate-1)</strong></p>
<p> <strong>rate最低只能选3</strong>，低于3会roll over，导致interrupt频率不准</p>
<p> <img src="/ECE391-MP3-Tutorial/Untitled6.png" alt="Untitled"></p>
</li>
</ol>
<hr>
<p><em><strong>handler:</strong></em></p>
<p>需要使用一个全局变量，并且需要volatile，来记录RTC产生interrupt的次数，当做时钟</p>
<p>这个数字，除以frequency，就可以得到当前过了多少秒，或者多少ms</p>
<ol>
<li><p><strong>if register C is not read after an IRQ 8, then the interrupt will not happen again</strong></p>
<p> 在每次handler之后需要加入一段</p>
<p> <img src="/ECE391-MP3-Tutorial/Untitled7.png" alt="Untitled"></p>
</li>
<li><p>然后send_EOI，STI</p>
</li>
</ol>
<hr>
<h3 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h3><p>键盘本身属于PS&#x2F;2 controller，使用PS&#x2F;2的port。读取键盘内容从<strong>0x60</strong>端口获得，<strong>connect to irq1</strong></p>
<p><img src="/ECE391-MP3-Tutorial/Untitled8.png" alt="Untitled"></p>
<p>command为一个byte，键盘会response “ACK” (to acknowledge the command) or a “Resend” (to say something was wrong with the previous command)</p>
<p>scan code set会表示哪个键被下压。scan code可能不止一个，最多6个bytes。当keyboard状态机知道现在scan code已经全部获取了，就可以将其转化成key code了。</p>
<p>我们的键盘属于US QWERTY，用SCAN CODE SET1</p>
<p><em><strong>Initialization:</strong></em></p>
<p>只需要enable_irq即可</p>
<p><em><strong>handler:</strong></em></p>
<ol>
<li>从port中读取数据   <code>inb(0x60)</code></li>
<li>利用提前建好的table对应ASCII<ol>
<li>检测是否为特殊键 shift caps….   如果是，暂时不做任何操作（或者可以在这个ckpt就把这个东西弄好）</li>
<li>对普通键，对应ASCII码并putc</li>
</ol>
</li>
<li>send EOI</li>
</ol>
<h2 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h2><p>reference: <a target="_blank" rel="noopener" href="https://wiki.osdev.org/Paging">https://wiki.osdev.org/Paging</a></p>
<h3 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h3><p>在 <code>kernel.c</code> 的 <code>entry</code>函数中添加 <code>page_init</code>函数， 调用 <code>page.c</code>中初始化分页的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Init the PIC */</span></span><br><span class="line">	i8259_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init paging */</span></span><br><span class="line">	page_init();</span><br></pre></td></tr></table></figure>

<h3 id="page-c-page-h"><a href="#page-c-page-h" class="headerlink" title="page.c, page.h"></a>page.c, page.h</h3><ol>
<li><p>在新文件 <code>page.h</code> 以及 <code>page.c</code> 中定义相关函数和数据结构</p>
<ul>
<li>page table需要自定义数据结构，参照OSdev或者x86手册</li>
</ul>
</li>
<li><p>定义函数</p>
<ul>
<li>需要完成对 <strong>page directory table</strong> 和 两个 <strong>page table</strong> 的初始化，并且写入内存中对应位置。page init部分实际上就是修改创建好的page tables中各个bit的值，对应所需要开启的paging部分</li>
<li>需要操作 CPU 的 <code>cr0</code>, <code>cr3</code>, <code>cr4</code> 寄存器，告知硬件page directory的位置并为 paging 开启硬件支持。这一步相当于激活上面一步初始化好的page directory和page table</li>
<li>cr0用于开启paging         cr4用于开启4MB page        cr3为TLB，即指示page directory位置</li>
</ul>
<p> page directory entry 和 page table entry 的结构：</p>
<p> <img src="/ECE391-MP3-Tutorial/Untitled9.png" alt="Untitled"></p>
</li>
</ol>
<h1 id="Checkpoint-2"><a href="#Checkpoint-2" class="headerlink" title="Checkpoint 2"></a>Checkpoint 2</h1><h2 id="Terminal-Driver"><a href="#Terminal-Driver" class="headerlink" title="Terminal Driver"></a>Terminal Driver</h2><hr>
<p>ToDo:</p>
<ol>
<li>完善键盘映射：Shift、CapsLock（Ctrl和Alt也需要用全局变量追踪，暂时没有更多作用——TA）</li>
<li>光标追踪：让打的字出现在光标处，需要支持上下滑动（其实只有向上；可以不用保留command history）。还需要支持Ctrl+L&#x2F;Ctrl+l的清屏操作</li>
<li>还需要支持退格键（直接改变光标）和行缓冲输入，缓冲区大小128B</li>
</ol>
<p><strong>read:</strong></p>
<p>从keyboard buffer中读取写入的字符，转移到terminal buffer中，返回读取的bytes总数</p>
<p>设置while循环，不断通过键盘向keyboard buffer中增加内容，扫描到enter才返回。缓冲区换入127个字符时，拒绝新进入的字符（停止更新缓冲区），等待一个enter的输入。（最后一个字符应为\n）</p>
<p>对于terminal，read多少字符，就把buffer中的多少个字符给清空，并将后面的挪动到前面来</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong>^ 其实可以直接覆写</strong></strong></strong></strong></strong></strong></strong></strong></p>
<p>read有两种情况会终止，第一种是read到指定byte数目，第二种是碰到了\n（其实只有一种？）</p>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>^ 只在读到\n时返回即可，越界时直接忽略后面的字符</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<p><strong>write:</strong></p>
<p>从传入的buf中读取所有内容，转移到屏幕上，返回written bytes数目或者-1</p>
<p><strong>注意需要滚动换行↓的情况：打印字符计数达到80时触发scrolling函数</strong></p>
<p><strong><strong>scrolling:</strong></strong></p>
<p>可能要修改putc函数，将上方所有内容向上移动一行，把最底下一行清空，然后再打印新的字符（直接更新vmem）</p>
<p><strong><strong>clear:</strong></strong></p>
<p>lib.c中的clear函数只有清理video memory的操作，没有重置下一个character应该出现的位置</p>
<p>↑但仍然是好事，差点就要写循环往vmem里赋零了（）</p>
<h2 id="Read-only-File-system"><a href="#Read-only-File-system" class="headerlink" title="Read-only File system"></a>Read-only File system</h2><hr>
<p>ToDo:</p>
<ol>
<li>open and read a file system image</li>
<li>copy program images into physical memory</li>
</ol>
<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a><strong><strong><strong><strong>基本数据结构</strong></strong></strong></strong></h3><p>每个Block 4kB，第一个block称为boot block，包含file system的整体统计信息（dir数量、inode数量、数据块数量）和所有的directory。统计信息、每个directory均占据64B</p>
<p>第一个directory总是代表当前directory，命名为.（一个点），所以实际上最多只能有62个其他files</p>
<p>每一个directory包含：32B文件名（不一定要包含EOS，也即未必有”\0”标记字符串尾）、4B文件类型、4B inode索引</p>
<p><img src="/ECE391-MP3-Tutorial/Untitled10.png" alt="Untitled"></p>
<p>file type 0 代表user level可以触碰的RTC，1 for directory，2 for regular file。对于RTC和directory，#inode是没有意义的。</p>
<p><img src="/ECE391-MP3-Tutorial/Untitled11.png" alt="Untitled"></p>
<p>以上三个函数都是失败return -1（fname不存在&#x2F;index不合法&#x2F;#inode不合法&#x2F;inode中数据块索引不合法）。前两个函数成功都会将dentry指针赋值成所需要的那个directory数据，第三个函数相当于“read”这一system call，返回读取了多少个byte</p>
<hr>
<p><strong><strong><strong><strong><strong><strong>与Task的联动：</strong></strong></strong></strong></strong></strong></p>
<p>每一个task最多开启8个file，它们被存在一个file array中，而file descriptor就是用来在array中找寻这些file的。file array中的每一个元素都应该储存以下四种信息</p>
<ol>
<li>对应这个file的各种操作函数，<strong>open, read, write, and close</strong> to perform type-specific actions for each operation.</li>
<li>inode number，对于directory或者RTC就是0</li>
<li>file position，指示用户在什么位置开启了这个file，由read system call更新</li>
<li>flag，用来指示当前descriptor正在使用</li>
</ol>
<p><img src="/ECE391-MP3-Tutorial/Untitled12.png" alt="Untitled"></p>
<p>open a file的流程：储存对应的jump table pointer，将flag设置成in-use</p>
<hr>
<h3 id="filesystem-init"><a href="#filesystem-init" class="headerlink" title="filesystem_init"></a><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>filesystem_init</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></h3><ol>
<li><p>找到File img的开头地址，File的所有信息在boot的时候就已经帮我们储存在了内存的某一个地方</p>
<p> 根据文档，每一个img都算是一个module，可以load进去</p>
<p> <img src="/ECE391-MP3-Tutorial/Untitled.jpeg" alt="Untitled"></p>
<p> <img src="/ECE391-MP3-Tutorial/Untitled13.png" alt="Untitled"></p>
</li>
<li><p>在<code>kernel.c</code>里进行file system初始化，将上面找到的指针传递给file system</p>
</li>
<li><p>传入的地址是boot_blcok的开头，直接将一个全局变量boot_block_ptr指向这个地方</p>
</li>
<li><p>boot_block中的3个num信息，赋值给3个全局变量，用于储存有多少个directory，有多少个inode，有多少个data_block</p>
</li>
<li><p>根据各个数字，找到inode的开头和data_block的开头，并将这两个地址储存在另外两个ptr中，以备后续使用</p>
</li>
</ol>
<p> tips：因为文件系统只读不写，可以用静态的全局变量储存这些所有信息</p>
<hr>
<h3 id="Three-base-functions"><a href="#Three-base-functions" class="headerlink" title="Three base functions"></a>Three base functions</h3><p><strong><strong>read_dentry_by_index:</strong></strong></p>
<ol>
<li>sanity check，如果index超出dir_num，return -1</li>
<li>将boot_block中的<code>dentries[index]</code>值赋给传入的dentry指针<ol>
<li>赋值过程中，filename必须用<code>lib.c</code>提供的<code>strncpy</code>，因为filename允许没有string结尾符<code>\0</code></li>
</ol>
</li>
</ol>
<p><strong><strong>read_dentry_by_name:</strong></strong></p>
<ol>
<li>设置一个index变量，遍历所有在boot_block的file name，每次index++</li>
<li>index++之后做check，如果已经超出dir_num，return -1</li>
<li>如果匹配到（利用<code>lib.c</code>中提供的<code>strncmp</code>），呼叫<code>read_dentry_by_index(index, dentry)</code>，让read_dentry_by_index完成真正的赋值操作</li>
</ol>
<p><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>read_data:</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p>
<ol>
<li>sanity check，确认(file总长度-offset)&gt;0 并且 inode_index &lt; boot_block拥有的inode数目-1</li>
<li>找到对应的inode，<code>inodes_arr[i]</code></li>
<li>计算需要从哪个data_block的哪个位置开始读取 offset &#x2F; block_size  +  offset % block_size</li>
<li>计算读取到哪个data_block的哪个位置</li>
<li>开始循环复制数据到buff中，同时要检测是否需要更换另一个data_block</li>
</ol>
<hr>
<p>问题：我们需要在这里实现file descriptor array吗？暂时不需要，在之后的scheduler部分出现了task struct再实现</p>
<hr>
<h2 id="The-Real-Time-Clock-Driver"><a href="#The-Real-Time-Clock-Driver" class="headerlink" title="The Real-Time Clock Driver"></a>The Real-Time Clock Driver</h2><p>reference:<a target="_blank" rel="noopener" href="https://wiki.osdev.org/RTC">https://wiki.osdev.org/RTC</a></p>
<p>做到和RTC交互，让user直接修改它的频率，最好能<strong>虚拟化</strong></p>
<p>虚拟化可以采用一个全局变量counter，每次interrupt产生都++，这里的interrupt看做是一个基础interrupt，采取最高频率，即1024Hz</p>
<p>对于不同频率，如果counter自这个read函数被创建后过了 1024&#x2F;frequency次，则return</p>
<p>例如：虚拟化的RTC_read需要一个512Hz的RTC，那么过了1024&#x2F;512&#x3D;2个interrupt后return</p>
<p>可能需要一个array，全部entries初始化为1，对不同的虚拟的RTC device储存各自的频率，interrupt实际上只改变counter。在后续ckpt中，有多个terminal，每一个terminal上执行的程序可能会设置不同的RTC频率，对应这个array中的一个freq</p>
<p><strong>open:</strong></p>
<p>将freq改为2Hz，返回0。flag设置为0。后续到了多进程时，freq和flag都有多个，每个进程对应一对freq和flag。</p>
<p><strong>close:</strong></p>
<p>返回0（文档如此）</p>
<p><strong>read:</strong></p>
<p>跟踪全局flag，用一个while loop让read函数陷入循环，直到flag被设置成1，跳出循环。跳出时再重新将flag设置为0，return。这样可以达到一种类似于linux中sleep的效果。</p>
<p><strong><strong><strong><strong><strong><strong>write:</strong></strong></strong></strong></strong></strong></p>
<p>先做sanity check，如果都通过，根据传入的frequency设置freq。此时暂时只有一个terminal，没有进程之间的切换，在后续ckpt中需要检查当前write指令是由哪一个进程调用的，修改这个进程对应的freq</p>
<p><strong>handler:</strong></p>
<p>使counter++，检查是否度过了freq个单位时间，如果是，将flag设置为1。设置为1的时候，之前某次调用的read函数就会返回。</p>
<p>具体相关端口，对rtc的交互请查看reference（OSdev）</p>
<hr>
<h1 id="Checkpoint-3"><a href="#Checkpoint-3" class="headerlink" title="Checkpoint 3"></a>Checkpoint 3</h1><h2 id="System-Calls"><a href="#System-Calls" class="headerlink" title="System Calls"></a>System Calls</h2><p>int $0x80呼叫，最多接受三个参数</p>
<p>call number, arg1, arg2, arg3 → EAX, EBX, ECX, EDX</p>
<p>成功return 0，失败return -1，返回值放在EAX</p>
<p>一部分不会返回（如halt）</p>
<p><strong>open</strong></p>
<p>在文件系统中找到文件，分配一个空闲的描述符并初始化（注意文件类型）</p>
<p><strong>close</strong></p>
<p>检测描述符合法性，后释放描述符</p>
<p><strong>read</strong></p>
<p>从RTC&#x2F;键盘&#x2F;文件&#x2F;目录读取数据，返回读取的bytes数量</p>
<p>RTC：接收到virtual interrupt时返回0</p>
<p>键盘：读取到\n时 或 buffer满时返回</p>
<p>文件：读取到EOF时 或 buffer满时返回</p>
<p>File Position指读取位置</p>
<p>system call的传入参数性质也决定了我们需要为它们编写一个wrapper(link)来保证参数正常传递</p>
<hr>
<h3 id="Wrapper-amp-Linkage"><a href="#Wrapper-amp-Linkage" class="headerlink" title="Wrapper &amp; Linkage"></a>Wrapper &amp; Linkage</h3><p>需要实现的10个system call最多只有三个参数，用asm写wrapper <strong>（这部分并不归我们写，提供的可执行文件包含了这部分wrapper）</strong></p>
<p>在IDT的0x80号位置调用包装函数</p>
<ol>
<li>callee saved</li>
<li>获取arguments，根据数目不同从EBX, ECX, EDX中获取</li>
<li>获取system call number，<code>int 0x80</code></li>
<li>restore callee saved</li>
</ol>
<hr>
<h3 id="System-call-handler"><a href="#System-call-handler" class="headerlink" title="System call handler"></a>System call handler</h3><ol>
<li><p>save all registers</p>
</li>
<li><p>check system call number is valid or not</p>
</li>
<li><p>利用已有的function table找到对应system call，从call之后的stack来看，获取参数应该在每一个system call所对应的函数之内  — 问题：如何让一个C function直接从寄存器中读取数值，fastcall？</p>
<p> 或者<strong>另一种解决办法，直接在system call handler中恢复C convention</strong></p>
<p> <img src="/ECE391-MP3-Tutorial/Untitled14.png" alt="Untitled"></p>
</li>
<li><p>检查返回值，失败与成功</p>
</li>
<li><p>restore register</p>
</li>
<li><p>重新设置关于iret所需要的一切</p>
</li>
<li><p>iret</p>
</li>
</ol>
<hr>
<h3 id="Execute-sys-call具体流程"><a href="#Execute-sys-call具体流程" class="headerlink" title="Execute sys call具体流程"></a>Execute sys call具体流程</h3><p>尝试加载一个新的程序</p>
<p>接收参数command（字符串）是一个以空格为分界的一连串words，第一个word是file name，之后的都由getargs获得</p>
<p>无法执行（命令不存在、非可执行文件）返回-1，Exception返回256，halt返回0~255的值</p>
<p><strong>Parse args</strong></p>
<p>对于<strong>file name</strong>，直接取出第一个空格之前的所有内容即可，写一个loop，直到char &#x3D;&#x3D; ’ ’停止</p>
<p>其他的arguments暂时好像用不到</p>
<p><strong>Check file validity</strong></p>
<ol>
<li>利用file name检查file中是否存在一样的文件，在这里利用<strong>read_dentry_by_name</strong>时可以把信息存在一个dentry变量中，接下来需要使用</li>
<li>再读取这个file的前4个bytes（<strong>read_data</strong>)，查看它是否是一个可执行文件</li>
<li>在这里也可以直接获取program第一条指令执行的位置（<strong>read_data</strong>），储存在可执行文件的24-27bytes</li>
</ol>
<p><strong>Create PCBs</strong></p>
<p>寻找到pid，当前是第几个process</p>
<p>为PCB分配空间，初始化，设置为active，其中kernel stack根据不同的pid有不同的值</p>
<p>Open File descriptor for stdin&#x2F;stdout</p>
<p><strong>Set up paging</strong></p>
<p>需要知道当前是第几个process，我们应该可以假设最多只有3个process（像PPT上一样）</p>
<p>直接在Page Directory中  ( 0x8000000(128MB) &gt;&gt;22 )，即2^5&#x3D;<strong>32位置修改映射</strong></p>
<p><strong>phy add &#x3D; 0x800000 + pid*4MB</strong>  将 PD[32]对应的4MB page起始点修改为 <strong>phy add &gt;&gt;12</strong>即可</p>
<p>记得flush tlb，即重新载入一遍cr3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *   set_user_prog_page</span></span><br><span class="line"><span class="comment"> *   Set page for a user program</span></span><br><span class="line"><span class="comment"> *   input: pid -- the pid of the user program</span></span><br><span class="line"><span class="comment"> *   output: None</span></span><br><span class="line"><span class="comment"> *   side effect: Change the paging directory; Change CR3; flush TLB</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>Load file(program) into memory</strong></p>
<p>file的起始点为USER_CODE 0x8048000</p>
<p><strong>Prepare for context switch</strong></p>
<p>mp3 system中只有一个tss，就是在<code>x86_desc.h</code>中的tss变量，在回到user level之前，tss中的相关参数需要被更新</p>
<p>不需要考虑schedule的情况下，只需要更改tss的值即可，在soft multitasking中，tss只有两个值是相关的，<em><em>更改SS0为kernel ds，ESP0为当前process的stack，即8MB-8KB</em>(pid)-1个byte、</em>*</p>
<aside>
➡️ esp0永远是8MB-8KB*(pid)-1，是因为每次从kernel回到user space，kernel stack都被“清空”，stack上实际的数据没有改变，但下一次回到kernel space，从栈底开始。这样做的原因是防止kernel stack overflow

</aside>

<p><img src="/ECE391-MP3-Tutorial/Untitled15.png" alt="Untitled"></p>
<p>iret需要的五个参数：</p>
<ul>
<li>user ds，直接用x86_desc.h中的user ds；</li>
<li>esp，user stack，位于128MB-132MB这一段memory的末尾，即132MB-4byte；</li>
<li>eflag，直接把当前的flag push进去可行吗？</li>
<li>cs，tss中的user cs；</li>
<li>eip，把上面储存的user program第一条指令对应的地址拿过来</li>
</ul>
<hr>
<h3 id="Halt-sys-call具体流"><a href="#Halt-sys-call具体流" class="headerlink" title="Halt sys call具体流"></a>Halt sys call具体流</h3><p>终止进程并返回母进程</p>
<p>Shell —”execute” syscall (when cmd is typed)→ Program</p>
<p>Program —”halt” syscall (when “return”)→ Shell</p>
<p>很重要的一点，如果我们要检测是否exception，需要在原来的exception while1改成呼叫halt的函数</p>
<p>halt的总体思想，利用parent process在kernel stack上存好的context来iret，以此回到parent process的user level</p>
<ol>
<li>首先check这是否是exception呼叫的</li>
<li>再看一下是否是shell，如果是shell本身出问题，需要重启shell，因为它是第一个program，不能被完全杀死</li>
<li>关闭file descriptor，将开启了的file均关闭，因为如果不关闭，之后重新利用这段pcb的时候会发现许多file都是“开启”状态</li>
<li>将当前的process设置为non-active</li>
<li>找到parent，并从parent的pcb中取出信息，将paging设置为parent program所需要的</li>
<li>将tss更新成parent的信息，SS0&#x3D;kernel ds，ESP0&#x3D;parent kernel stack</li>
<li>再从parent pcb中找到之前的context信息，具体而言，是从parent pcb中重新取回之前的ebp和esp，之后再leave+ret就相当于从execute这个syscall的地方返回，直接用这些context信息来进行iret</li>
</ol>
<hr>
<h2 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h2><p>此次不用完成scheduler，但需要在某一个program产生exception时回到shell</p>
<p>所有tasks共享一个4MB内核态分页。对于一个而言，其task映像（代码）的物理地址是固定的而且每个小于4MB，分配一个用户态分页即可。</p>
<hr>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>在文件系统驱动中，将程序代码从随机分配&amp;排列（也即分散）的4kB disk blocks拷贝到连续的物理地址中</p>
<p>注意维护栈，拷贝在内核态执行，拷贝结束后要回到用户态</p>
<hr>
<h2 id="Executing-User-level-Code"><a href="#Executing-User-level-Code" class="headerlink" title="Executing User-level Code"></a>Executing User-level Code</h2><p>注意内核态程序不能调用用户态程序，要实现privilege switch</p>
<p>IRET的正常运行要求提供ESP EIP EFLAGS CS SS等寄存器值</p>
<p>EIP → 位于可执行文件24~27B的entry point</p>
<p>ESP → 载入可执行文件的4MB分页末尾</p>
<p>CS → user code segment</p>
<p>DS → user data segment</p>
<p>SS → user stack segment （有声明吗？）</p>
<p>而且需改变TSS</p>
<hr>
<h2 id="Process-Control-Block"><a href="#Process-Control-Block" class="headerlink" title="Process Control Block"></a>Process Control Block</h2><p>需储存的Per-Task State包括</p>
<p>File array（记录开启的文件）</p>
<p>Signal information → extra credit内容，可以不识闲</p>
<p>Kernel stack（每个8kB）</p>
<p>两个task的kernel stack分别占用第4080<del>4087、4088</del>4095kB</p>
<p>parent pid</p>
<p>excute_ebp &#x2F; excute_esp 用于halt</p>
<hr>
<h1 id="Checkpoint-4"><a href="#Checkpoint-4" class="headerlink" title="Checkpoint 4"></a>Checkpoint 4</h1><h2 id="getargs"><a href="#getargs" class="headerlink" title="getargs"></a>getargs</h2><p>在execute内调用</p>
<p>参数（以字符串的形式）存储在PCB，裁剪（头部）可执行文件名&amp;空格、（尾部）空格</p>
<p>例：在Shell #0中运行” cat  arg1   arg2    “，将”arg1   arg2”存入PCB #1（注意空格数量）</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>在buf中传入用户输入的命令</p>
<p>检测头部空格结束的位置、尾部空格开始的位置</p>
<p>将两个位置之间的args字符串拷贝进PCB（args之间可以有任意数量空格，交给user program处理）</p>
<p>成功返回0，失败（args****************************************************************************+NULL****************************************************************************太大&#x2F;检测不到args）返回-1</p>
<p>最好把PCB #0（shell）的args字符串设置为”\0”</p>
<h2 id="vidmap"><a href="#vidmap" class="headerlink" title="vidmap"></a>vidmap</h2><p>需要DPL &#x3D; 0以访问物理内存vmem，影响安全性。解决方案为将vmem映射到虚拟内存</p>
<p>*screen_start指向虚拟内存地址（用户给定）</p>
<p>双重指针的作用是允许访问整个新的4kB page</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implimentation</span></span><br><span class="line"><span class="type">uint8_t</span>* screen_start = vidmap();</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="type">uint_t</span>* screen_start;</span><br><span class="line">vidmap(screen_start);</span><br></pre></td></tr></table></figure>

<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>检查*screen_start的合法性：应大于128MB，小于132MB（？）</p>
<p>修改PD和PT实现mapping，将DPL设置为3供用户访问（？）</p>
<p>成功返回<strong>0xB8000</strong>，失败返回-1</p>
<hr>
<h1 id="Checkpoint-5"><a href="#Checkpoint-5" class="headerlink" title="Checkpoint 5"></a>Checkpoint 5</h1><h2 id="Multiple-Terminals"><a href="#Multiple-Terminals" class="headerlink" title="Multiple Terminals"></a>Multiple Terminals</h2><p>3个terminal，最多同时运行6个程序</p>
<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><ul>
<li>Initial bootup: 在系统启动时就初始化三个进程</li>
<li>After bootup: 用Alt+F1&#x2F;F2&#x2F;F3切换，当用户第一次按下ALT+F2&#x2F;F3时开启新的terminal</li>
</ul>
<h3 id="Separate-I-x2F-O-buffer"><a href="#Separate-I-x2F-O-buffer" class="headerlink" title="Separate I&#x2F;O buffer"></a>Separate I&#x2F;O buffer</h3><p>每一个terminal结构体中存储独立的I&#x2F;O buffer、光标、显示屏上的文字、active flag</p>
<p>在切换出terminal的时候存起来，切换回来的时候重新载入</p>
<h3 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h3><p>退出某一个terminal的shell时，不会立即重启，直到把最后一个shell也退出时才需要重启shell</p>
<p>在halt修改一下重启条件，判断是否是最后一个shell</p>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p><img src="/ECE391-MP3-Tutorial/Untitled16.png" alt="multi terminal 内存示意图"></p>
<p>multi terminal 内存示意图</p>
<p>需要新分配三块backup video memory，类似build buffer的作用，每一块都储存着当前terminal的video memory，在切换的时候进行载入</p>
<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h3><p>在<code>terminal.c</code>中定义<code>void switch_terminal(uint8_t term_index)</code>函数，在<code>keyboard.c</code>中调用</p>
<ol>
<li>Sanity check，传入index是否越界</li>
<li>判断term_index是否为当前current_term_index（全局变量），若是则直接返回</li>
<li>切换流程(以从terminal1切换到terminal2为例子)<ol>
<li>video map到current terminal，即让0xB8000指向phyiscal的0xB8000</li>
<li>将当前vmem存到属于terminal1的backup内存块（term1 video page）中</li>
<li>将terminal2的backup内存块载入vmem</li>
<li>设置光标位置，此时屏幕更新完成</li>
<li>更新全局变量current_term_id</li>
<li>video map到当前正在schedule的process</li>
</ol>
</li>
</ol>
<p>tips: video map指的是更新virtual 0xB8000指向的physical memory映射关系，以下为函数的描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   remap_vidmap_page</span></span><br><span class="line"><span class="comment"> *   Set page for video memory for a specific terminal.</span></span><br><span class="line"><span class="comment"> *   If terminal_id = active one, directly write into physical memory.</span></span><br><span class="line"><span class="comment"> *   If terminal_id != active one, map user video memory to corresponding backup buffer.</span></span><br><span class="line"><span class="comment"> *   input: screen_start -- starting address of the video memory</span></span><br><span class="line"><span class="comment"> *   output: None</span></span><br><span class="line"><span class="comment"> *   side effect: Change the paging directory; Change CR3; flush TLB */</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><p>跟踪所有活跃的task，每隔10-50ms轮流切换执行</p>
<p>被暂停的task不应该打印信息，需要动态更新page table以将显示映射到0xB8000以外的地方</p>
<h3 id="PIT"><a href="#PIT" class="headerlink" title="PIT"></a>PIT</h3><p>reference: <a target="_blank" rel="noopener" href="https://wiki.osdev.org/PIT">OSDEV Link for PIT</a></p>
<p>Scheduling中计时使用PIT而非RTC，因为RTC的优先级太低了</p>
<p>在PIT发生一次interrupt时调用handler（在IDT中注册），在handler中进行一次schedule操作</p>
<p>使用Chanel0作为I&#x2F;O Port    <code>0x40   Channel 0 data port (read/write)</code></p>
<p>向0x43 port写入选择的channel，mode</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>在进行具体流程之前，必须明确一个事实。一个不是正在执行的process的stack上，<strong>必然是scheduler的残留信息</strong>，因为process只要开始执行，只有两种可能退出当前stack：</p>
<ol>
<li>执行完毕，返回user space</li>
<li>还未执行完毕，但是被scheduler强制退出，去往其他process</li>
</ol>
<p>所以只要我们发现可以找到next process，那这个process一定是属于2情况，即stack上残留了上一次scheduler未return的所有信息，在接下来的task switch中，以为switch的时候依然使用的是scheduler的代码，直接更改esp、ebp即可</p>
<p><img src="/ECE391-MP3-Tutorial/Untitled17.png" alt="Untitled"></p>
<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h3><p><strong>核心思想1：scheduler通过更改esp, ebp实现在kernel stack之间的切换</strong></p>
<ol>
<li><p>PIT产生interrupt，在其<code>pit_handler</code>中呼叫<code>scheduler_linkage (asm)</code></p>
</li>
<li><p>进入scheduler后，先<strong>储存本次scheduler进入时的ebp</strong>，储存到<code>pcb→sch_ebp</code>中</p>
</li>
<li><p>找到在schedule array中的下一个需要被schedule的process，以下称为**<code>next process</code>**，并更新<code>cur_sch_index</code>（用来指示当前schedule是哪个process的变量）</p>
</li>
<li><p>若next process的pid为-2(TERM_NOT_INIT宏)，代表下一个terminal上还没有被初始化任何进程</p>
<ol>
<li><code>remap_video_page(cur_sch_index)</code> 接下来的一切和video相关操作会作用在即将新开启的shell process上</li>
<li>执行<code>execute(&#39;shell&#39;)</code></li>
</ol>
 <aside>
 ➡️ 这样做可以解决刚开始三个process的kernel stack上都没有scheduler残余的问题。三个空的kernel stack会一个个被初始化成为有scheduler残余的kernel stack
 
 </aside>
 </li>
<li><p>如果下一个terminal已经有进程可以被schedule了：为进入user space做准备，对user program的map进行调整，即对program image进行更改</p>
<p> 将user program部分指向physical memory中next process的program image。和execute使用一个更改user program paging的函数</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*   set_user_prog_page</span></span><br><span class="line"><span class="comment"> *   Set page for a user program</span></span><br><span class="line"><span class="comment"> *   input: pid -- the pid of the user program</span></span><br><span class="line"><span class="comment"> *   output: None</span></span><br><span class="line"><span class="comment"> *   side effect: Change the paging directory; Change CR3; flush TLB */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改变TSS，为回到kernel space做准备</p>
</li>
<li><p>remap user video memory</p>
</li>
<li><p>准备context switch到即将切换到的process</p>
<p> 不能直接使用iret，而是<strong>重新载入另一个process的ebp</strong>，只是相当于换了一个kernel stack</p>
<ol>
<li>在scheduler中，将next process <code>pcb→ sch_ebp</code>取出来，这个ebp储存的是上一次从刚刚进入scheduler时的stack state</li>
<li>将这个pcb→sch_ebp赋值给ebp，再leave+ret，实际上是从next process kernel stack上回到了pit handler</li>
</ol>
</li>
<li><p>在切换stack之后，回到了PIT handler，PIT handler再return，则可以利用PIT lnk(asm)中的iret，可以switch到next process的user space</p>
</li>
</ol>
<hr>
<p><img src="/ECE391-MP3-Tutorial/Untitled18.png" alt="Untitled"></p>
<p>virtual的0xB8000指向scheduled process的backup buffer，如果和display terminal是一个，则指向physical的0xB8000</p>
<p>键盘的字符永远要输入到physical的0xB8000</p>
<h3 id="Video-memory-problems"><a href="#Video-memory-problems" class="headerlink" title="Video memory problems"></a>Video memory problems</h3><p>上述实现逻辑会造成video memory出现一定的错乱问题，需要对<code>lib.c</code>中的<code>putc</code>函数进行一定的更改</p>
<p>keyboard interrupt呼叫putc，默认朝0xB8000进行输入。但在schedule过程中，0xB8000因为video_remap的原因，未必时刻指向真实的video memory，可能指向backup buffer。但实际上，keyboard的输入应该显示在当前展示的terminal上，而非当前scheduled的terminal上。</p>
<p>而terminal_write中呼叫的putc，则需要显示在当前scheduled的terminal上，而非当前展示的terminal，这与keyboard逻辑有所不同</p>
<p>在已经提供的许多user program中，大多数向屏幕上打印的方法是呼叫terminal_write，而<code>fish.c</code>是使用<code>vidmap</code>直接获取地址然后修改值</p>
<p>这一部分比较繁琐细碎，但并不困难，这个笔记里不过多赘述。</p>
<hr>
<h1 id="Extra-Credit"><a href="#Extra-Credit" class="headerlink" title="Extra Credit"></a>Extra Credit</h1><h2 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h2><p>Two types of memory management</p>
<ol>
<li>Fixed length memory allocation</li>
<li>Varaible length memory allocation</li>
</ol>
<h3 id="Fixed-length-—-Slab-Cache"><a href="#Fixed-length-—-Slab-Cache" class="headerlink" title="Fixed length — Slab Cache"></a>Fixed length — Slab Cache</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In this specific implementation, fixed length memory allocation is implemented by two parts, memory management unit and memory unit.</span><br><span class="line">fixed length diagram:</span><br><span class="line">        |memory management unit|  |memory management unit|  |memory management unit|  ..........    |memory unit|  |memory unit| |memory unit| .....</span><br><span class="line">        |next|  ---------------&gt;  |next|  ---------------&gt;  |next|                                      ↑              ↑             ↑</span><br><span class="line">        |ptr|---------------------|ptr|---------------------|ptr|---------------------------------------↑--------------↑-------------↑</span><br></pre></td></tr></table></figure>

<p>Data structure: Linked list</p>
<ul>
<li>Slab_Create ( name , size )</li>
<li>destroy , malloc , free</li>
<li>Automatically shrinks and grows</li>
<li>quick and fast to allocate and free</li>
<li>granularity: 1byte - 4kB-8 bytes</li>
</ul>
<h3 id="Variable-length-—-Implicit-free-list"><a href="#Variable-length-—-Implicit-free-list" class="headerlink" title="Variable length — Implicit free list"></a>Variable length — Implicit free list</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">On the other hand, variable length memory allocation is implemented very similar to Linux<span class="number">&#x27;</span>s implicit <span class="built_in">free</span> <span class="built_in">list</span> design. </span><br><span class="line">A memory part consists of two parts, memory management unit and real useable memory unit.</span><br><span class="line">Memory management units are held in a linked <span class="built_in">list</span> to track each memory fragments have been allocated.</span><br><span class="line">variable length diagram:</span><br><span class="line">        |memory mangement unit| -&gt; |memory mangement unit| -&gt; |memory mangement unit| -&gt; |memory mangement unit|</span><br><span class="line">        -----------------------    -----------------------    -----------------------    -----------------------</span><br><span class="line">        |                     |    |                     |    |                     |    |                     |</span><br><span class="line">        |   useable memory    |    |   useable memory    |    |   useable memory    |    |   useable memory    |</span><br><span class="line">        |                     |    |                     |    -----------------------    |                     |</span><br><span class="line">        |                     |    -----------------------                               -----------------------</span><br><span class="line">        |                     |</span><br><span class="line">        -----------------------</span><br><span class="line"></span><br><span class="line">Slab cache<span class="number">&#x27;</span>s implementation is based on fixed length memory allocation.</span><br></pre></td></tr></table></figure>

<p>Data structure: Implicit free list</p>
<ul>
<li>varmalloc( size )</li>
<li>flexible: can allocate any size</li>
<li>granularity: 1byte - 4MB</li>
</ul>
<h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p>Support users to set handler they define</p>
<p>Support sigreturn and set_handler syscall</p>
<p>Support five signals:</p>
<ol>
<li>SIG_DIV_ZERO</li>
<li>SIG_SEGFAULT</li>
<li>SIG_INTERRUPT</li>
<li>SIG_ALARM</li>
<li>SIG_USER1</li>
</ol>
<h2 id="ATA-Hard-Disk-Support-amp-File-System"><a href="#ATA-Hard-Disk-Support-amp-File-System" class="headerlink" title="ATA Hard Disk Support &amp; File System"></a>ATA Hard Disk Support &amp; File System</h2><ul>
<li><p>Writable file system</p>
  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write fname contents</span><br></pre></td></tr></table></figure>
</li>
<li><p>Persistent Change (after reboot) by saving the change to the hard drive</p>
</li>
<li><p>How the file system is loaded and initialized:</p>
</li>
</ul>
<p><img src="/ECE391-MP3-Tutorial/Untitled19.png" alt="Untitled"></p>
<h2 id="Speaker-Driver"><a href="#Speaker-Driver" class="headerlink" title="Speaker Driver"></a>Speaker Driver</h2><p>Toggle <strong><strong><strong><strong><strong><strong><strong>NumLock</strong></strong></strong></strong></strong></strong></strong> to turn on&#x2F;off</p>
<p>Key mapping:</p>
<p>(C3~E4) ZSXDCVGBHNJM,L.;&#x2F;</p>
<p>(C4~G5) Q2W3ER5T6Y7UI9O0P[&#x3D;]</p>
<p>Runs concurrently with any user programs &amp; across terminals</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/First-Post/" rel="prev" title="First Post">
      <i class="fa fa-chevron-left"></i> First Post
    </a></div>
      <div class="post-nav-item">
    <a href="/ZinixOS/" rel="next" title="ZinixOS">
      ZinixOS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ECE391-MP3"><span class="nav-number">1.</span> <span class="nav-text">ECE391 MP3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Checkpoint-1"><span class="nav-number">2.</span> <span class="nav-text">Checkpoint 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OS-Booting-GDT-amp-IDT-Setup"><span class="nav-number">2.1.</span> <span class="nav-text">OS Booting: GDT &amp; IDT Setup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GDT"><span class="nav-number">2.1.1.</span> <span class="nav-text">GDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDT"><span class="nav-number">2.1.2.</span> <span class="nav-text">IDT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Device-and-Interrupt"><span class="nav-number">2.2.</span> <span class="nav-text">Device and Interrupt</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PIC"><span class="nav-number">2.2.1.</span> <span class="nav-text">PIC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTC"><span class="nav-number">2.2.2.</span> <span class="nav-text">RTC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keyboard"><span class="nav-number">2.2.3.</span> <span class="nav-text">Keyboard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Paging"><span class="nav-number">2.3.</span> <span class="nav-text">Paging</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kernel-c"><span class="nav-number">2.3.1.</span> <span class="nav-text">kernel.c</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page-c-page-h"><span class="nav-number">2.3.2.</span> <span class="nav-text">page.c, page.h</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Checkpoint-2"><span class="nav-number">3.</span> <span class="nav-text">Checkpoint 2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Terminal-Driver"><span class="nav-number">3.1.</span> <span class="nav-text">Terminal Driver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Read-only-File-system"><span class="nav-number">3.2.</span> <span class="nav-text">Read-only File system</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filesystem-init"><span class="nav-number">3.2.2.</span> <span class="nav-text">filesystem_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Three-base-functions"><span class="nav-number">3.2.3.</span> <span class="nav-text">Three base functions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Real-Time-Clock-Driver"><span class="nav-number">3.3.</span> <span class="nav-text">The Real-Time Clock Driver</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Checkpoint-3"><span class="nav-number">4.</span> <span class="nav-text">Checkpoint 3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#System-Calls"><span class="nav-number">4.1.</span> <span class="nav-text">System Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrapper-amp-Linkage"><span class="nav-number">4.1.1.</span> <span class="nav-text">Wrapper &amp; Linkage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-call-handler"><span class="nav-number">4.1.2.</span> <span class="nav-text">System call handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Execute-sys-call%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.3.</span> <span class="nav-text">Execute sys call具体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Halt-sys-call%E5%85%B7%E4%BD%93%E6%B5%81"><span class="nav-number">4.1.4.</span> <span class="nav-text">Halt sys call具体流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tasks"><span class="nav-number">4.2.</span> <span class="nav-text">Tasks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader"><span class="nav-number">4.3.</span> <span class="nav-text">Loader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executing-User-level-Code"><span class="nav-number">4.4.</span> <span class="nav-text">Executing User-level Code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process-Control-Block"><span class="nav-number">4.5.</span> <span class="nav-text">Process Control Block</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Checkpoint-4"><span class="nav-number">5.</span> <span class="nav-text">Checkpoint 4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#getargs"><span class="nav-number">5.1.</span> <span class="nav-text">getargs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">5.1.1.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vidmap"><span class="nav-number">5.2.</span> <span class="nav-text">vidmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Checkpoint-5"><span class="nav-number">6.</span> <span class="nav-text">Checkpoint 5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Multiple-Terminals"><span class="nav-number">6.1.</span> <span class="nav-text">Multiple Terminals</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Initialization"><span class="nav-number">6.1.1.</span> <span class="nav-text">Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Separate-I-x2F-O-buffer"><span class="nav-number">6.1.2.</span> <span class="nav-text">Separate I&#x2F;O buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Isolation"><span class="nav-number">6.1.3.</span> <span class="nav-text">Isolation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Switch"><span class="nav-number">6.1.4.</span> <span class="nav-text">Switch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">6.1.5.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scheduling"><span class="nav-number">6.2.</span> <span class="nav-text">Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PIT"><span class="nav-number">6.2.1.</span> <span class="nav-text">PIT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scheduler"><span class="nav-number">6.2.2.</span> <span class="nav-text">Scheduler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">6.2.3.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Video-memory-problems"><span class="nav-number">6.2.4.</span> <span class="nav-text">Video memory problems</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Extra-Credit"><span class="nav-number">7.</span> <span class="nav-text">Extra Credit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Allocation"><span class="nav-number">7.1.</span> <span class="nav-text">Memory Allocation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fixed-length-%E2%80%94-Slab-Cache"><span class="nav-number">7.1.1.</span> <span class="nav-text">Fixed length — Slab Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Variable-length-%E2%80%94-Implicit-free-list"><span class="nav-number">7.1.2.</span> <span class="nav-text">Variable length — Implicit free list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Signal"><span class="nav-number">7.2.</span> <span class="nav-text">Signal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ATA-Hard-Disk-Support-amp-File-System"><span class="nav-number">7.3.</span> <span class="nav-text">ATA Hard Disk Support &amp; File System</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Speaker-Driver"><span class="nav-number">7.4.</span> <span class="nav-text">Speaker Driver</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zicheng Ma</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ZichengMa" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ZichengMa" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/zma17@illinois.edu" title="E-Mail → zma17@illinois.edu"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Friend Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://silkrow3.wordpress.com/" title="https:&#x2F;&#x2F;silkrow3.wordpress.com&#x2F;" rel="noopener" target="_blank">ErkaiYu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://moomoohorse.com/home/" title="https:&#x2F;&#x2F;moomoohorse.com&#x2F;home&#x2F;" rel="noopener" target="_blank">HaoRen</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zicheng Ma</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
